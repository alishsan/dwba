m
complex
'complex
(v/magsq 4 5)
exit
(require '[fastmath.core :as m])
(require '[fastmath.vectors :as m])
(require '[fastmath.vector :as m])
(require '[fastmath.vector :as v])
(require '[fastmath.core :as m])
(v/mag [1 2 3])
(require '[fastmath.polynomials :as poly])
exit
(require '[fastmath.polynomials :as poly])
exit
(require '[fastmath.polynomials :as poly])
(poly/eval-legendre-P 4. 5.)
(poly/legendre-P 4.)
(poly/legendre-P 1.)
(first (poly/legendre-P 1.))
(poly/evaluate (poly/legendre-P 1.) 4)
exit
poly
(poly/evaluate (poly/legendre-P 1.) 4)
exit
(plot/plot {:x (range 10) :y (map #(* % %) (range 10))})
(require '[cljplot.core :as plot])
exit
(plot/plot {:x (range 10) :y (map #(* % %) (range 10))})
exit
(def my-data {:x [1 2 3 4 5]
              :y [10 15 8 12 20]})
(plot/xy-chart {:title "My Sample Plot"}
               my-data)
(xy-chart {:title "My Sample Plot"}
               my-data)
(show (xy-chart {:title "My Sample Plot"}
               my-data))
(let [chart (plot/xy-chart {:title "My Sample Plot"} my-data)]
  ;; Save the chart as an image
  (plot/save chart "output/my-plot.png")
  
  ;; Show the chart interactively
  (plot/show chart))
(let [chart (xy-chart {:title "My Sample Plot"} my-data)]
  (save chart "output/my-plot.png")
  (show chart))
exit
(in-ns plot)
(in-ns complex)
exit
(in-ns hanami)
(in-ns dwba/hanami)
(in-ns dwba.hanami)
exit
(in-ns 'plot)
my-data
plot
exit
ys
exit
deriv
(hankel0+ 0 1)
(hankel0- 0 1)
(hankel0- 0 1.001)
exit
deriv
(macroexpand 'deriv)
(macroexpand deriv)
exit
deriv
(macroexpand deriv)
(defmacro infix
  "Use this macro when you pine for the notation of your childhood"
  [infixed]
  (list (second infixed) (first infixed) (last infixed)))
(defmacro infix
  [infixed1 inf2 inf 3]
))
(defmacro infix
  [infixed1 inf2 inf3]
  (list inf2 infix1 inf3))
(defmacro infix
  [inf1 inf2 inf3]
  (list inf2 inf1 inf3))
(infix 2 + 3)
(defmacro infix-2
  [[operand1 op operand2]]
  (list op operand1 operand2))
(infix-2 2 + 3)
(infix-2 (2 + 3))
exit
deriv
exit
(use 'complex)
clojure -M test_fastmath.clj
timeout 10s clojure -M quick_fastmath_test.clj
clojure -M simple_comparison.clj
(require '[fastmath.special.hypergeometric :as hg])
(require '[fastmath.complex :as cplx])
(let [z (cplx/complex 2 -1)  ; 2 - i
      a 4.0
      b cplx                 ; This should be cplx/I (imaginary unit)
      result (hg/tricomis-U-complex z a b)]
  (println "=== HG Tricomis-U-Complex Test ===")
  (println "Input:")
  (println "  z = 2 - i = " z)
  (println "  a = " a)
  (println "  b = cplx = " b)
  (println "Result:")
  (println "  hg/tricomis-U-complex(2-i, 4.0, cplx) = " result)
  (println "  Real part = " (cplx/real result))
  (println "  Imaginary part = " (cplx/imag result))
  (println "  Magnitude = " (cplx/abs result))
  (println "  Phase = " (cplx/arg result) " radians"))
; Test the corrected function call
(let [z (cplx/complex 2 -1)  ; 2 - i
      a 4.0
      b cplx/I              ; imaginary unit (not just cplx)
      result (hg/tricomis-U-complex z a b)]
  (println "=== HG Tricomis-U-Complex Test ===")
  (println "Input:")
  (println "  z = 2 - i = " z)
  (println "  a = " a)
  (println "  b = cplx/I = " b)
  (println "Result:")
  (println "  hg/tricomis-U-complex(2-i, 4.0, cplx/I) = " result)
  (println "  Real part = " (cplx/real result))
  (println "  Imaginary part = " (cplx/imag result))
  (println "  Magnitude = " (cplx/abs result))
  (println "  Phase = " (cplx/arg result) " radians"))
(println "\n✅ Test completed!")
exit
;; Copy and paste this into the REPL to test hg/tricomi-U-complex
;; First, require the necessary namespaces
(require '[fastmath.special.hypergeometric :as hg])
(require '[fastmath.complex :as cplx])
;; Test the corrected function call
(let [z (cplx/complex 2 -1)  ; 2 - i
      a 4.0
      b cplx/I              ; imaginary unit (not just cplx)
      result (hg/tricomi-U-complex z a b)]
  (println "=== HG Tricomi-U-Complex Test ===")
  (println "Input:")
  (println "  z = 2 - i = " z)
  (println "  a = " a)
  (println "  b = cplx/I = " b)
  (println "Result:")
  (println "  hg/tricomi-U-complex(2-i, 4.0, cplx/I) = " result)
  (println "  Real part = " (cplx/real result))
  (println "  Imaginary part = " (cplx/imag result))
  (println "  Magnitude = " (cplx/abs result))
  (println "  Phase = " (cplx/arg result) " radians"))
(println "\n✅ Test completed!")
exit
(require '[fastmath.special.hypergeometric :as hg])
(require '[fastmath.complex :as cplx])
(hg/tricomi-U-complex (cplx/complex 2 -1) 4.0 cplx/I)
(require '[fastmath.special :as spec])
(require '[fastmath.complex :as cplx])
(spec/tricomi-U-complex (cplx/complex 2 -1) 4.0 cplx/I)
(spec/tricomis-U-complex (cplx/complex 2 -1) 4.0 cplx/I)
(spec/tricomis-U-complex (cplx/complex 2 -1) 2.0 cplx/I)
(spec/tricomis-U-complex (cplx/complex 1 -0.5) 1.0 cplx/I)
(spec/tricomis-U-complex (cplx/complex 2 -0.5) 1.0 cplx/I)
(spec/tricomis-U-complex (cplx/complex 2 -1) 1.0 cplx/I)
(spec/tricomis-U-complex (cplx/complex 2 1) 1.0 cplx/I)
(spec/tricomis-U-complex (cplx/complex 2 1) 1.5 cplx/I)
exit
